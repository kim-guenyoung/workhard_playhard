/*int가 4바이트이고, short는 2바이트인 시스템을 기준으로 3바이트짜리 정수 자료형을 추가로 만들 수 있을까? 결론부터 말하자면 없다.
기본 자료형을 추가하는 것은 불가능하기 때문이다. 그렇지만, 기본 자료형 변수를 묶어서 새로운 자료형을 정의하는 것은 가능하다.
그리고 이는 프로그램 개발에 있어 매우 중요한 위치를 차지한다. 기본 자료형만 가지고는 필요한 유형의 데이터를 모두 표현하는 데는 한계가 존재한다.*/
/*
struct person //person이라는 이름의 구조체 정의
{
	char name[20];
	char phoneNum[20];
	int age;
};*/
//위 예제에서 보았듯 배열도 값의 저장이 가능한, 사실상 변수의 성격을 띠기 때문에 구조체의 멤버가 될 수 있다.

//구조체 변수와 포인터
//구조체 배열의 선언 및 접근의 방법이 일반적인 배열의 선언 및 접근의 방법과 다르지 않듯이
//구조체 포인터 변수의 선언 및 연산 방법도 일반적인 포인터 변수의 선언 및 연산의 방법과 다르지 않다.
/*
int num = 10;
int* iptr = &num;
//point형 구조체의 포인터 변수도 다음과 같이 선언하고 초기화한다.
struct point pos = { 11, 12 }; //xpos, ypos를 11, 12로 초기화
struct point* pptr = &pos; //포인터 변수 pptr이 구조체 변수 pos를 가리킴
*iptr = 20; //포인터 변수 iptr을 이용해서 다음과 같이 변수 num에 접근하듯이 point형 포인터 변수 pptr을 이용해 다음과 같이 구조체 변수 pos에 접근할 수 있다.

(*pptr).xpos = 10; //pptr이 가리키는 구조체 변수의 멤버 xpos에 10 저장
(*pptr).ypos = 20; //pptr이 가리키는 구조체 변수의 멤버 ypos에 20 저장
접근을 위해 포인터 변수를 대상으로 * 연산을 하는 것은 동일하다.
다만 구조체 포인터 변수의 경우 접근하고자하는 멤버의 선택을 위해 .연산을 추가한 것이다.
pptr->xpos = 10; //pptr이 가리키는 구조체 변수의 멤버 xpos에 10 저장
pptr->ypos = 20; //pptr이 가리키는 구조체 변수의 멤버 ypos에 20 저장

★즉 *연산과 .연산을 하나의 -> 연산으로 대신할 수 있는 것이다.
그러나 많은 프로그래머들이 편의상 ->연산자를 즐겨쓰니 나 또한 익숙해지는 게 좋을 듯 싶다.
*/